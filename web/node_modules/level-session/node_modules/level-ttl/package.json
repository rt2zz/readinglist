{
  "name": "level-ttl",
  "description": "Adds a 'ttl' option to LevelUP for puts and batches",
  "version": "0.0.1",
  "homepage": "https://github.com/rvagg/node-level-ttl",
  "authors": [
    "Rod Vagg <rod@vagg.org> (https://github.com/rvagg)"
  ],
  "keywords": [
    "leveldb",
    "levelup",
    "ttl"
  ],
  "main": "./level-ttl.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/rvagg/node-level-ttl.git"
  },
  "dependencies": {
    "after": "~0.7.0",
    "level-sublevel": "~4.6.1",
    "xtend": "~2.0.3"
  },
  "peerDependencies": {},
  "devDependencies": {
    "tap": "*",
    "levelup": "~0.8.0",
    "rimraf": "~2.1.4"
  },
  "scripts": {
    "test": "node ./test.js"
  },
  "license": "MIT",
  "readme": "# Level TTL [![Build Status](https://secure.travis-ci.org/rvagg/node-level-ttl.png)](http://travis-ci.org/rvagg/node-level-ttl)\n\n![LevelDB Logo](https://twimg0-a.akamaihd.net/profile_images/3360574989/92fc472928b444980408147e5e5db2fa_bigger.png)\n\n**Add a `'ttl'` (time-to-live) option to LevelUP for `put()` and `batch()`**\n\nAugment LevelUP to handle a new `'ttl'` option on `put()` and `batch()` that specifies the number of milliseconds an entry should remain in the data store. After the TTL, the entry will be automatically cleared for you.\n\n```js\nvar levelup = require('levelup')\n  , ttl     = require('level-ttl')\n\nlevelup('/tmp/foo.db', function (err, db) {\n  db = ttl(db)\n\n  // --------------------------- put() --------------------------- //\n  // this entry will only stay in the data store for 1 hour\n  db.put('foo', 'bar', { ttl: 1000 * 60 * 60 }, function (err) { /* .. */ })\n\n  // -------------------------- batch() -------------------------- //\n  // the two 'put' entries will only stay in the data store for 1 hour\n  db.batch([\n      { type: 'put', key: 'foo', value: 'bar' }\n    , { type: 'put', key: 'bam', value: 'boom' }\n    , { type: 'del', key: 'w00t' }\n  ], { ttl: 1000 * 60 * 60 }, function (err) { /* .. */ })\n})\n```\n\nIf you put the same entry twice, you **refresh** the TTL to the *last* put operation. In this way you can build utilities like [session managers](https://github.com/rvagg/node-level-session/) for your web application where the user's session is refreshed with each visit but expires after a set period of time since their last visit.\n\n**Level TTL** uses an internal scan every 10 seconds by default, this limits the available resolution of your TTL values, possibly delaying a delete for up to 10 seconds. The resolution can be tuned by passing the `'checkFrequency'` option to the `ttl()` initialiser.\n\n```js\nlevelup('/tmp/foo.db', function (err, db) {\n  // scan for deletables every second\n  db = ttl(db, { checkFrequency: 1000 })\n\n  /* .. */\n})\n```\n\nOf course, a scan takes some resources, particularly on a data store that makes heavy use of TTLs. If you don't require high accuracy for actual deletions then you can increase the `'checkFrequency'`. Note though that a scan only involves invoking a LevelUP ReadStream that returns *only the entries due to expire*, so it doesn't have to manually check through all entries with a TTL. As usual, it's best to not do too much tuning until you have you have something worth tuning!\n\n## Licence\n\nLevel TTL is Copyright (c) 2013 Rod Vagg [@rvagg](https://twitter.com/rvagg) and licensed under the MIT licence. All rights not explicitly granted in the MIT license are reserved. See the included LICENSE file for more details.",
  "readmeFilename": "README.md",
  "_id": "level-ttl@0.0.1",
  "dist": {
    "shasum": "c67cbd506db0478116ec7d75b715251df95950c9"
  },
  "_from": "level-ttl@~0.0.0",
  "_resolved": "https://registry.npmjs.org/level-ttl/-/level-ttl-0.0.1.tgz"
}
