{
  "author": {
    "name": "Mikeal Rogers",
    "email": "mikeal.rogers@gmail.com"
  },
  "name": "jaws",
  "description": "Build HTTP applications as a cache.",
  "version": "0.7.0",
  "main": "index.js",
  "scripts": {
    "test": "node test/run.js"
  },
  "dependencies": {
    "mime": "~1.2.9",
    "mapleTree": "~0.5.0-1",
    "lru-cache": "~2.2.2",
    "json-stringify-safe": "~3.0.0"
  },
  "devDependencies": {
    "request": "~2.10.0"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "# Jaws (this is not a framework)\n\n```javascript\nvar jaws = require(\"jaws\")\nvar app = jaws()\napp.route(\"/to/:place\", function (req, res) {\n  // This is where your code goes.\n})\napp.httpServer.listen(80, function () {\n  console.log(\"Running now.\")\n})\n```\n\n#### Routes\n\nJaws is an API for dealing with HTTP, it is not a framework. Say it with me **\"Jaws is not a framework.\"**\n\nYou create a Jaws instance which is what you hang your routes off of.\n\nThe routes you create are also objects which you can add properties to.\n\n```javascript\napp.route('/input', function (req, res) {\n  // This is where code you write to take input goes.\n})\n.methods(\"PUT\", \"POST\")\n;\n```\n\nThat would be how you could require that the HTTP methods `PUT` and `POST` were used and if not a proper HTTP error would be returned.\n\nYou can also add `conditions` to routes, code that will be executed before the handler and is required for that route. All conditions fire at once and are not ordered or sequential.\n\n```javascript\napp.route('/me', function (req, res) {\n  res.html(templateRender(req.user))\n})\n.must(function (req, res, cb) {\n  if (!req.headers.cookie) cb(new Error('No cookie header'))\n  getUserByToken(req.headers.cookie, function (e, user) {\n    req.user = user\n    cb(e, user)\n  })\n})\n```\n\nYou can also add named conditions to the application. All conditions will fire for every request but HTTP errors will only be enforced for those that are required by each route.\n\n```javascript\napp.condition('auth', 401, function (req, res, cb) {\n  if (!req.headers.cookie) cb(new Error('No cookie header'))\n  getUserByToken(req.headers.cookie, function (e, user) {\n    req.user = user\n    cb(e, user)\n  })\n})\n\napp.route('/me', function (req, res) {\n  res.html(templateRender(req.user))\n})\n.must('auth')\n\n// This will still work without auth because there's no `must()` call.\napp.route('/').file('index.html')\n```\n\nAnd lastly, you can listen to events fired for application level conditions.\n\n```javascript\napp.condition('auth', 401, function (req, resp, cb) {\n  if (!req.headers.cookie) cb(new Error('No cookie header'))\n  getUserByToken(req.headers.cookie, function (e, user) {\n    req.user = user\n    cb(e, user)\n  })\n})\n\napp.route('/user/:userid', function (req, resp) {\n  resp.statusCode = 200\n  resp.end(req.user)\n})\n.condition(401, function (req, resp, cb) {\n  req.on('condition.auth', function (e, user) {\n    if (req.user.id !== req.routes.params.userid) return cb('You can only access your own user document.')\n    cb(null, user)\n  })\n})\n.must('auth')\n;\n```\n\n#### Aggressive Caching\n\nJaws has the most aggressive caching semantics of any HTTP API I know of. **The full body of every GET request is cached by URL in an LRU cache and held indefinitely.**\n\nThe only way to clear something from cache is to flush it by URL or matching route.\n\n```javascript\npubsub.on('change', function (id) {\n  if (id === 'globals') {\n    // When pubsub tells us the globals change flush all our pages\n    app.flush('/pages/*')\n  }\n  // When pubsub tells us an id changes flush the web page for it\n  app.flush('/pages/'+id)\n})\n```\n\nYou can also flush the entire cache quite easily.\n\n```javascript\n// Regularly flush the whole cache\nsetInterval(1000 * 60 * 60, function () {\n  app.flush()\n})\n```\n\nFor obvious reasons HTTP methods other than `HEAD` and `GET` are not cached. You can also avoid the caching of a route by using `nocache()`.\n\n```javascript\napp.route('/dynamic',function (req, res) {\n  // Your app code.\n})\n.nocache()\n;\n```\n\n\n## API\n\n#### Application\n\n* `condition(name, [statusCode], cb)` - Add a condition globally to the application. cb in form of HTTP req/res + final callback `function (req, res, cb) {cb(error, success)}`. All conditions will fire for all requests but only routes that use `must()` will get an HTTP error if the callback gets an error.\n* `route(pattern, [cb])` - Create and return a Route instance for `pattern`. Optionally pass a handler in form of HTTP req/res `function (req, res) {}`.\n* `flush([pattern])` - Flush cache entries that match `pattern`. Flushes entire cache when no pattern is given.\n* `addHeader(name, value)` - Add a header to all responses.\n\n#### Route\n\n* `must(*names)` - Require named conditions be fulfilled. Accepts as many arguments as you like.\n* `methods(*names)` - Only accept requests of the given HTTP methods. Lowercase method names are allowed.\n* `condition(cb)` - Add a condition to this route. cb in form of HTTP req/res + final callback `function (req, res, cb) {cb(error, success)}`.\n* `nocache()` - Do not attempt to cache this route.\n* `files(directory)` - Serve the files from this directory for this route. For obvious reason the route should end in `/*`\n* `file(filepath)` - Serve a static file for this route.\n\n### Convenience methods\n\nJaws sparingly adds some methods to the node's request and response objects for your convenience.\n\n#### Request\n\n* `body(cb)` - Parse the incoming request body and call `cb`. JSON and URL encoded bodies will be parsed. cb is standard callback interface `function (error, body) {}`.\n* `route` - A [mapleTree](https://github.com/saambarati/mapleTree) route instance. `req.route.params` is most used and holds the parsed request params.\n\n#### Response\n\n* `error(err, [statusCode])` - Return an HTTP error. Accept instances of Error and text and, optionally, a statusCode (defaults to 500).\n* `notfound()` - Return an HTTP 404.\n* `html(body, [statusCode])` - Write the HTML body, set proper headers, and end the response.\n* `json(obj, [statusCode])` - Safely serialize (uses [json-stringify-safe](https://github.com/isaacs/json-stringify-safe)) the object to JSON, set proper headers, end the request.\n\n",
  "readmeFilename": "README.md",
  "_id": "jaws@0.7.0",
  "dist": {
    "shasum": "064f0695b73c6753e9e3e494ce703d6b7ca2693a"
  },
  "_from": "jaws@",
  "_resolved": "https://registry.npmjs.org/jaws/-/jaws-0.7.0.tgz"
}
